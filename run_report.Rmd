---
title: "Post-Distribution Monitoring Report"
author: "The Emergency Response for IDPs, Returnees, and Conflict-Affected Communities in Yemen (Phase 2)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  word_document:
    toc: true
    reference_docx: ./wordStylesReferenceMC.docx
  pdf_document: default
params:
  form_id: NA
  password: NA
  username: NA
---

```{r setup, include=FALSE}
# This is the automated PDM Report template. This file should be run in R Studio to produce the PDM Report
# This file works with the template form found HERE #todo and the wordStylesReferenceMC.docx

# This is a code chunk, these boxes are where the calculations take place
# Text in a code chunk with a # in front of it is a comment and is used to explain what is happening

# This chunk, setup, loads the R packages that will be used
# You shouldn't need to make any changes here unless you are an advanced user

knitr::opts_chunk$set(echo = TRUE, results = 'asis')
knitr::opts_chunk$set(dpi = 300, fig.width=6)

# Checks if necessary packages are installed on the system, if not installs them
# Need to be online for this to work, and may take some time the first time your run. Only required to install once
# and will run much faster the second time
list.of.packages <- c("tidyverse", "rmarkdown", "knitr", "ggthemes", "pander", "reshape", "summarytools", "here")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

# Loads the required packages
library(tidyr)     # extra functions
library(httr)      # accessing the REST API
library(jsonlite)  # parsing the JSON from the API
library(stringr)   # format column names, label names, otherwise work with strings
library(dplyr)     # data manipulation
library(ggplot2)   # graphing
library(rmarkdown) # to generate the report
library(knitr)     # making the final word document
library(pander)    # markdown formatting
library(ggthemes)  # extra themes for the graphics
library(reshape)   # for changing dfs from wide to long
library(summarytools) # on some machines this may require installing an Xquartz library locally
library(here)      # for file path referencing

# renv is used to track package dependencies and store a working snapshot that can always be used as a backup in case a package upgrade throws things off
## renv::revert(commit = '')
## renv::restore()

# Sets global options for the document that control some appearance settings
st_options('omit.headings', TRUE)
st_options('bootstrap.css', FALSE)
st_options('footnote', NA)
#more param options here https://bookdown.org/yihui/rmarkdown/params-knit.html#knit-with-custom-parameters

```

```{r ona_pull, include=FALSE}
# This is where the data from Ona gets pulled into R for processing
# You shouldn't need to make any changes here. If you encounter errors with importing contact hcamp@mercycorps.org

# GET the information from Ona, using the form_id, username and password params
  ona_raw_request <- GET(paste0("https://api.ona.io/api/v1/data/", params$form_id), 
                        authenticate(params$username, params$password))

# Makes the dataframe with submissions from Ona
  ona_df <- content(ona_raw_request,"text") %>%    # this gets the actual context from the HTTP request
              fromJSON()                           # This converts the JSON to an R dataframe

# putting dates into a useable format
  # ona_df$ymdDate <- ymd(ona_df$today)

# saving df copy for reference if needed
  # save(ona_df, file = "ona_df.RData")

# loading saved Ona df, if needed
  # load("ona_df.RData")

```

```{r functions, include = FALSE}

# This function makes the SADD categories when passed sex c(male, female, unknown) and age in years. The function may not be needed in all reports.
makeSADD <- function(sex, age) {
  if (is.character(sex) && is.numeric(age)) {
      ADD <- "unknown"
      ADD <- ifelse(age >= 0  & age <6,  "O_5",   ADD)
      ADD <- ifelse(age >= 6  & age <10, "6_9",   ADD)
      ADD <- ifelse(age >= 10 & age <15, "10_14", ADD)
      ADD <- ifelse(age >= 15 & age <20, "15_19", ADD)
      ADD <- ifelse(age >= 20 & age <25, "20_24", ADD)
      ADD <- ifelse(age >= 25 & age <35, "25_34", ADD)
      ADD <- ifelse(age >= 35 & age <50, "35_49", ADD)
      ADD <- ifelse(age >= 50,           "50_",   ADD)
      
      SADD <- ifelse(sex == "male"   | sex == "Male"   | sex == "m" | sex == "M", 
                     paste0("M",ADD), 
                    ifelse(sex == "female" | sex == "Female" | sex == "f" | sex == "F", 
                           paste0("F",ADD), 
                           paste0("U", ADD))
                      )
      SADD
  } else {
    stop("At least one of the inputs is not correct, please check that the age variable is numeric and the sex variable is character.")
  }
}

# formatting charts function
format_chart <- function(textang = 0, legend_name = "Legend", legend_pos = "top") {
  list(
    theme_bw(),
    theme(axis.text.x = element_text(face = "bold", angle = textang, hjust = 1),
          legend.position = legend_pos),
    scale_fill_pander(name = legend_name)
  )
}

```


```{r pre_process, include = FALSE, cache = FALSE}
## if distributions need to be labeled programmatically, code should be added here
# may need to embed in a shiny app

# trim whitespace from before and after a column's values if it is a character column
ona_df <- ona_df %>% 
              mutate_if(is.character, trimws)

# load data dictionary to determine which Ona variable names match to the necessary objects
data_dict <- read.csv("AutoPDMReport_datadictionary.csv", stringsAsFactors = FALSE)

# create named list of var names for referencing
vars <- as.list(data_dict[, 2])
names(vars) <- data_dict[, 1]

# store codebook table for uncoding data
codebook <- read.csv("AutoPDMReport_codebook.csv", stringsAsFactors = FALSE)
codebook_vars <- unique(codebook$auto_var)

# uncode coded data
# TODO replace funs with list
for (i in seq_along(codebook_vars)) {
  codebook_snip <- filter(codebook, auto_var == codebook_vars[i]) %>% 
    select(source_code, end_code)
  ona_df <- mutate_at(ona_df, vars(vars[[codebook_vars[i]]]), funs(codebook_snip$end_code[match(., codebook_snip$source_code)]))
}

# reorder factors
ona_df[[vars$time_tosite]] <- factor(ona_df[[vars$time_tosite]],levels = c("<30 minutes", "30 mins - 1 hour", "1-2 hours", ">2 hours"))
ona_df[[vars$time_atsite]] <- factor(ona_df[[vars$time_atsite]], levels = c("<30 minutes", "30 mins - 1 hour", "1-2 hours", ">2 hours"))

lookup_yn <- data.frame(factor = c("yes", "no"),
                        value = c(1, 0))

# calculate CSI scores for later charting

## Create lookup table to decode variable names into strings and assign weights

csi_weights <- c(1, 2, 1, 3, 1)

  lookup_csi <- data.frame(factor = c(vars$copinga_food_lesspref, vars$copinga_food_help, vars$copinga_food_fewmeals, vars$copinga_food_lessadult, vars$copinga_food_mealsize), 
                           strategies = c("Relied on less preferred, less expensive food", 
                                          "Borrowed food or relied on help from friends or relatives", 
                                          "Reduced the number of meals eaten per day", 
                                          "Restrict consumption by adults in order for young children to eat", 
                                          "Reduced portion size of meals"), 
                           weights = csi_weights)

  ## calculate CSI scores and store
scores <- select(ona_df, one_of(vars$id, vars$geo, vars$copinga_food_lesspref, vars$copinga_food_help, vars$copinga_food_fewmeals, vars$copinga_food_lessadult, vars$copinga_food_mealsize)) %>%  
  # filter(distribution == "Distribution 3") %>%
  # select(-distribution) %>% 
  melt(., id.vars = c(vars$id, vars$geo)) %>% 
  merge(., lookup_csi, by.x = "variable", by.y = "factor") %>% 
  mutate(value_n = as.numeric(as.character(value)), 
         score = value_n * weights) %>% 
  group_by(!!sym(vars$id), !!sym(vars$geo)) %>% 
  summarise(household_csi = sum(score))

##TODO clean up <NA>s in all data to NA

```


# How to use this report

##### This report is not a final PDM report. The charts and tables are updated with your most recent data, so you do not need to produce these. However, the narrative and interpretation of the graphs should explain the reasons behind household behavior, and must be provided by someone with knowledge of the program.

##### Text that is highlighted should be deleted and replaced with the necessary narratives. Text that is not highlighted is automatically generated, and the numbers within the text automatically calculated. You may leave the non-highlighted text as is, delete it, or add additional context to it.


# Highlights

##### Provide summary bullet points here, including both good and bad findings. A few examples of things that could be included: "The no show rate for card distribution increased significantly in the reporting period, reaching 28%, compared to 10% in the previous quarter", "Cash assistance predominantly goes to pay for food and rent", "Cash assistance is not sufficient to meet all needs. Fifty-nine percent of cash recipients have to take on additional debt in order to cope, and 20% reduce the amount of food consumed. However, a majority of respondents report that cash assistance helps them a great deal to meet their basic needs."

\newline

## Acronyms  

```{r table1, echo = FALSE}
# add acronym to the first vector, following the pattern
# add definition to the second vector, it is important that they are in the same order

Acronyms <- c("UCT",
              "IDP", 
              "MEL", 
              "MPCA",
              "SADD")

Definitions <- c("Unconditional Cash Transfer",
                 "Internally Displaced Person", 
                 "Monitoring, Evaluation, and Learning", 
                 "Multi Purpose Cash Assistance",
                 "Sex and Age Disaggregated Data")

data.frame(Acronyms, Definitions) %>% kable()

```

***

# Distribution Overview

##### Insert an overview of the program and the distribution here, including the target groups, distribution type and amounts, distribution partners, etc.

## Methodology

##### Insert an overview here.

## Tool and Sample Size

##### Give details on the questionnaire, the respondent selection, sampling methodology, sample size, and margin of error.

The total number of respondents was `r nrow(ona_df)`.

## Data Collection and Analysis  

Data was collected and stored using the Ona digital data collection software. Data was cleaned and analyzed using the R open-source statistical language, and a template report was written in RMarkdown. The template R script is stored and documented on [Github](github.com/xxxx).

Individual reports include the output of the template RMarkdown file (in which graphics are updated using the most recent data), and contextual/written analysis provided by the program Monitoring & Evaluation staff.

## Limitations

##### Provide any information here which may inform the reader about the limitations of the survey you conducted, or the data you were able to gather.

***

# PDM Findings

## Findings on the distribution process

This section discusses findings about the quality of the distribution process, including the process for beneficiary selection, respondents' understanding of the distribution process, their experiences during the distribution, and their experiences in transit.

### Respondent knowledge of the distribution

Of the respondents, `r round(sum(ona_df[[vars$why_selected]] == "yes")/nrow(ona_df), digits = 2)*100`% understood why their household was selected, and `r round(sum(ona_df[[vars$fair_selected]] == "yes")/nrow(ona_df), digits = 2)*100`% felt the selection process was fair.

##### If significant numbers of beneficiaries thought the selection process was unfair, insert qualitative analysis about the explanations given here.

\newline

#### Figure 1: Profile of respondents' knowledge of distribution
```{r, echo=F, message=F, warning=F}

# as.data.frame call required because there's a known issue with dplyr outputs which gives it attributes that are not just df-like, so it needs to be converted to a df before melt will work
filtered <- select(ona_df, one_of(vars$geo, vars$informed_amount_yn, vars$informed_nodist_yn, vars$amount_entitled)) %>%
  #mutate_all(., funs(stringr::str_to_title)) %>% 
  mutate_at(vars(one_of(vars$informed_amount_yn, vars$informed_nodist_yn, vars$amount_entitled)), funs(lookup_yn$value[match(., lookup_yn$factor)])) %>% 
  group_by(!!sym(vars$geo)) %>% 
  summarise(informed_amount = sum(!!sym(vars$informed_amount_yn))/n()*100, 
            informed_nodist = sum(!!sym(vars$informed_nodist_yn))/n()*100, 
            entitled = sum(!!sym(vars$amount_entitled))/n()*100) %>% 
  as.data.frame(.) %>%  
  melt(., id.vars = vars$geo)

# create label vector
labels <- c("Were you informed how much you will receive?", "Were you informed how many times you will receive the cash?", "Do you feel that you received the amount of cash that you were entitled to?")

ggplot(filtered, aes(x = variable, y = value, fill = !!sym(vars$geo))) +
  geom_col(position = "dodge") +
  labs(x = "", 
       y = "% of respondents",
       title = "Percentage of households answering 'Yes'") +
    scale_x_discrete(labels = str_wrap(labels, width = 20)) + 
  coord_flip() +
  format_chart(legend_name = "District") +
  geom_text(aes(label = paste0(as.character(round(value, digits = 1)), "%")), position = position_dodge(width=0.9), size = 2.5)

```

\newline

Of the respondents, `r round(sum(ona_df[[vars$informed_amount_yn]] == "yes")/nrow(ona_df), digits = 3)*100`% were informed of how much money they would receive, and `r round(sum(ona_df[[vars$informed_nodist_yn]] == "yes")/nrow(ona_df), digits = 3)*100`% were informed of how many times they would receive it. Of those respondents who were informed, on average they believed they would receive `r mean(ona_df[[vars$informed_amount]], na.rm = T)`YER in cash in `r mean(ona_df[[vars$informed_nodist]], na.rm = T)` distributions.

##### Insert qualitative analysis about the explanations given here.

### Respondent experience with logistics of cash distribution

With regard to how they received cash, `r round(sum(ona_df[[vars$dist_method]] == "through_a_hawa")/nrow(ona_df), digits = 2)*100`% of respondents received the cash from a Hawala, while `r round(sum(ona_df[[vars$dist_method]] == "through_mercy_")/nrow(ona_df), digits = 2)*100`% received it from Mercy Corps staff.

\newline

#### Figure 2: Distribution attendance
```{r, echo = FALSE}

# the function in the ggplot call reorients the order of the bars to be from most frequent to least
ggplot(ona_df, aes(x = reorder(!!sym(vars$dist_attn), !!sym(vars$dist_attn),
                     function(x)-length(x)), fill = !!sym(vars$geo))) +
  geom_bar(position = "dodge") +
  labs(x = "", 
       y = "# of respondents",
       title = "Who went to the distribution site to receive the cash?") +
  format_chart(textang = 45, legend_name = "District")
  
```

\newline

***

\newline

#### Figure 3: Travel time needed
```{r, echo = FALSE, message=F}

#Note: combine this and the following chart into one
ggplot(ona_df, aes(x = !!sym(vars$time_tosite), fill = !!sym(vars$time_tosite))) +
  geom_bar() +
  labs(x = "", 
       y = "# of respondents",
       title = "How long did it take to reach the cash distribution site?") +
  facet_grid(eval(expr(. ~ !!sym(vars$geo)))) +
  format_chart(textang = 45, legend_pos = "none")
  
```

\newline

***

\newline

#### Figure 4: Distribution wait time
```{r, echo = FALSE}

ggplot(ona_df, aes(x = !!sym(vars$time_atsite), fill = !!sym(vars$time_atsite))) +
  geom_bar() +
  labs(x = "", 
       y = "# of respondents",
       title = "How long did you have to wait at the distribution site to get cash?") +
  facet_grid(eval(expr(. ~ !!sym(vars$geo)))) +
  format_chart(textang = 45, legend_pos = "none")
  
```

\newline

##### Insert any qualitative analysis desired for the wait times.

\newline

***

\newline

#### Table 1: Was the person giving you the cash polite and professional to you? (# of respondents)
```{r table2, echo = FALSE, warning = FALSE, message = FALSE}

table <- table(as.data.frame(as.matrix(select(ona_df, one_of(vars$geo, vars$professionalism)))))

pandoc.table(table)

```

***

\newline

Additional findings on the logistical elements of the distribution:

* `r round(sum(ona_df[[vars$problems_collect]] == "yes")/nrow(ona_df), digits = 2)*100`% of respondents faced problems collecting the cash.
* Roughly `r round(sum(ona_df[[vars$documentation]] == "National ID")/nrow(ona_df), digits = 2)*100`% of respondents used a National ID as identification in collecting the cash, while `r round(sum(ona_df[[vars$documentation]] == "Passport")/nrow(ona_df), digits = 2)*100`% used a passport, `r round(sum(ona_df[[vars$documentation]] == "Election ID")/nrow(ona_df), digits = 2)*100`% used an Election ID, `r round(sum(ona_df[[vars$documentation]] == "MC ID")/nrow(ona_df), digits = 2)*100`% used an MC ID, `r round(sum(ona_df[[vars$documentation]] == "Family ID")/nrow(ona_df), digits = 2)*100`% used a Family ID, and `r round(sum(ona_df[[vars$documentation]] == "Military ID")/nrow(ona_df), digits = 2)*100`% used a Military ID.

***

#### Table 2: Problems experienced during the distribution

```{r, echo = FALSE}

# create table that excludes unused options and geographies
table <- table(as.data.frame(as.matrix(select(ona_df, one_of(vars$problems, vars$geo)))), useNA = "no")

# create table
pandoc.table(table)
  
```

\newline

#### Figure 5: Costs to reach the distribution site
```{r, echo=F, message=F, warning=F}

ggplot(select(ona_df, one_of(vars$id, vars$geo, vars$costs_tosite)), aes(x = !!sym(vars$geo), y = !!sym(vars$costs_tosite))) +
  geom_jitter(aes(fill = !!sym(vars$geo)), 
              width = 0.1, alpha = 0.4, shape = 21) +
  geom_boxplot(aes(fill = !!sym(vars$geo)), colour = "black", width = 0.4,
               show.legend = FALSE, outlier.shape = NA, alpha = 0.4) +
  xlab("") +
  ylab("YER") +
  theme_bw() +
  scale_fill_pander(guide = FALSE) +
  scale_color_pander(guide = FALSE)
  
```

***

### Trends in distribution process quality

##### These sections can only be generated after multiple distributions have been conducted.

\newline

#### Figure 6: Change in perceptions of beneficiary selection fairness
```{r, echo = FALSE}

if(exists("distribution") == TRUE) {
  filtered <- select(ona_df, one_of(vars$distribution, vars$fair_selected, vars$geo)) %>%
    mutate_at(vars(vars$fair_selected), funs(lookup_yn$value[match(., lookup_yn$factor)])) %>%  
    group_by(!!sym(vars$distribution), !!sym(vars$geo)) %>% summarise(fair = sum(!!sym(vars$fair_selected))/n()*100)

  ggplot(filtered, aes(x = !!sym(vars$distribution), y = !!sym(vars$fair), group = !!sym(vars$geo))) +
    geom_line(aes(color = !!sym(vars$geo))) +
    geom_point(aes(color = !!sym(vars$geo))) +
    labs(x = "", 
         y = "% of respondents") +
    format_chart()
} else {
  print("Data for multiple distributions not found. If there is data for multiple distributions, check if your distribution variable is properly assigned in the data dictionary.")
}
  
```

\newline

##### Insert qualitative analysis of the trends here.

\newline

***

\newline

#### Figure 7: Costs to reach the distribution site
```{r, echo=F, message=F, warning=F}

if(exists("distribution") == TRUE) {

ggplot(select(ona_df, one_of(vars$id, vars$distribution, vars$costs_tosite)), aes(x = !!sym(vars$distribution), y = !!sym(vars$costs_tosite))) +
  geom_jitter(aes(fill = !!sym(vars$distribution)), 
              width = 0.1, alpha = 0.4, shape = 21) +
  geom_boxplot(aes(fill = !!sym(vars$distribution)), colour = "black", width = 0.4,
               show.legend = FALSE, outlier.shape = NA, alpha = 0.4) +
  xlab("") +
  ylab("YER") +
  theme_tufte() +
  scale_fill_pander(guide = FALSE) +
  scale_color_pander(guide = FALSE)
  
} else {
  print("Data for multiple distributions not found.")
}
  
```

***

### Conclusions on distribution process

##### Insert conclusions about how to improve future distributions here.

***

\newline

## Profile of Respondents and Cash Use

This section discusses findings on the characteristics of survey respondents, and how they utilized the cash received.

### Respondent Profile

#### Table 3: Household Status of respondents (SADD)

```{r table4, echo = FALSE}

table <- select(ona_df, one_of(vars$age, vars$gender, vars$household_status)) %>% 
  mutate(sadd = paste(!!sym(vars$gender), !!sym(vars$age), sep = "_")) %>% 
  select(sadd, !!sym(vars$household_status)) %>% 
  table(.)

pandoc.table(table)

```

***

#### Figure 8: Respondent population profile
```{r, echo = FALSE}

filtered <- select(ona_df, one_of(vars$geo, vars$hoh, vars$worked_pastmonth, vars$malnutrition, vars$breadwinner_lost, vars$breadwinner_nowork)) %>% 
  mutate_at(vars(one_of(vars$hoh, vars$worked_pastmonth, vars$malnutrition, vars$breadwinner_lost, vars$breadwinner_nowork)), funs(lookup_yn$value[match(., lookup_yn$factor)])) %>% 
  group_by(!!sym(vars$geo)) %>% 
  summarise(breadwinner_nowork = sum(!!sym(vars$breadwinner_nowork))/n()*100,
            breadwinner_lost = sum(!!sym(vars$breadwinner_lost))/n()*100,
            malnutrition = sum(!!sym(vars$malnutrition))/n()*100,
            worked_pastmonth = sum(!!sym(vars$worked_pastmonth))/n()*100, 
            hoh = sum(!!sym(vars$hoh))/n()*100) %>% 
  as.data.frame(.) %>%  
  melt(., id.vars = vars$geo)

labels <- c("Is the primary breadwinner no longer able to work?", "Has HH lost the primary breadwinner?", "Anyone in family treated for SAM?", "Has anyone in HH worked in past month?", "Are you the head of household?")

ggplot(filtered, aes(x = variable, y = value, fill = !!sym(vars$geo))) +
  geom_col(position = "dodge") +
  labs(x = "", 
       y = "% of respondents",
       title = "Percentage of households answering 'Yes'") +
    scale_x_discrete(labels = str_wrap(labels, width = 20)) + 
  coord_flip() +
  format_chart(legend_name = "District") +
  geom_text(aes(label = paste0(as.character(round(value, digits = 1)), "%")), position = position_dodge(width=0.9), size = 2.5)
  
```

***

General findings about usage of the distributed cash:

* `r round(sum(ona_df[[vars$cash_shared]] == "yes")/nrow(ona_df), digits = 2)*100`% of respondents shared items bought using the cash assistance with other people living in the household.
* `r round(sum(ona_df[[vars$amount_spent]] == "100%")/nrow(ona_df), digits = 2)*100`% of respondents reported that they had spent all of the cash assistance, while `r round(sum(ona_df[[vars$amount_spent]] == "0%")/nrow(ona_df), digits = 2)*100`% reported that they had not spent any of it. The most frequent reason given for not spending all of the cash was "`r names(sort(table(ona_df[[vars$amount_spent_reasons]]), decreasing = TRUE)[1])`", and the second most frequent reason was "`r names(sort(table(ona_df[[vars$amount_spent_reasons]]), decreasing = TRUE)[2])`".
* `r round(sum(ona_df[[vars$amount_sufficient]] == "yes")/nrow(ona_df), digits = 2)*100`% of respondents reported that the amount was sufficient to cover their basic needs for one month.
* `r round(sum(ona_df[[vars$access_goods]] == "yes")/nrow(ona_df), digits = 2)*100`% of respondents reported that they were able to access the goods/services they wanted to buy with the cash assistance.

\newline

#### Table 3: If respondent was unable to access desired goods/services, what was the challenge? 

```{r table5, echo = FALSE}

pandoc.table(table(select(ona_df, one_of(vars$challenges, vars$geo))))

```

##### Insert qualitative narrative here around the reasons (if any) why they could not buy what they wanted with the cash.

\newline

#### Figure 9: Needs covered by cash assistance
```{r, echo = FALSE}

ona_df %>% 
  drop_na(!!sym(vars$proportion_needs_covered)) %>% 
  ggplot(aes(x = !!sym(vars$proportion_needs_covered), fill = !!sym(vars$proportion_needs_covered))) +
  geom_bar() +
  labs(x = "\nProportion covered", 
       y = "# of respondents",
       subtitle = "If the cash was not sufficient to cover household basic needs, what is the proportion of the needs it covered?") +
  #scale_fill_discrete(name = "Sex of Respondent", labels = c("Female", "Male")) + 
  #scale_x_discrete(labels = c("Yes", "No")) + 
  facet_grid(eval(expr(. ~ !!sym(vars$geo)))) +
  format_chart(textang = 45, legend_pos = "none")

```

##### Insert narrative here.

***

\newline

### Use of cash assistance

#### Figure 10: Uses of cash assistance
```{r, echo=F, message=F, warning=F}

# select expenditure variables, convert to numeric, and calculate colSums to find the top 8 uses of the cash
expvars <- select(ona_df, contains("group_hh68n58"))
expvars <- as.data.frame(sapply(expvars, as.numeric))
varSums <- sort(colSums(expvars), decreasing = TRUE)[1:8]

# isolate and clean up names for the top 8 uses for plotting
names <- names(varSums)
names_plot <- gsub("group_hh68n58/", "", names)
names_plot <- gsub("_", " ", names_plot)

# get data to chart
filtered <- cbind(id = seq(1, nrow(ona_df)), expvars) %>% 
  select(id, names) %>% 
  melt(., id.vars = "id")

ggplot(filtered, aes(x = variable, y = value)) +
  geom_jitter(aes(fill = variable), 
              width = 0.1, alpha = 0.4, shape = 21) +
  geom_boxplot(aes(fill = variable), colour = "black", width = 0.5,
               show.legend = FALSE, outlier.shape = NA, alpha = 0.4) +
  xlab("") +
  ylab("YER") +
  labs(subtitle = "Of the cash assistance you have spent, how much did you spend on each of the \nfollowing categories in the last two weeks? (Top 8 Expenses)") +
  scale_x_discrete(labels = str_wrap(names_plot, width = 20)) +
  format_chart(textang = 45) +
  scale_color_pander() +
  theme(legend.position = "none")
  
```

***

### Coping Strategies Index

As noted in the World Food Programme's [Coping Strategies Index Manual](https://documents.wfp.org/stellent/groups/public/documents/manual_guide_proced/wfp211058.pdf), the logic of the Coping Strategies Index (CSI) is to help analysts understand the target population's answer(s) to the following question: "What do you do when you don’t have enough food, and don’t have enough money to buy food?" From the manual: "The basic idea is to measure the frequency of these coping behaviors (how often is the coping strategy used?) and the severity of the strategies (what degree of food insecurity do they suggest?). Information on the frequency and severity is then combined in a single score, the Coping Strategies Index, which is an indicator of the household’s food security status."

The Reduced Coping Strategies Index (rCSI) tracks five common short-term and long-term coping strategies that are relatively universal, and the prevalence of each can help to illustrate the severity of food insecurity in a target population in a manner that is comparable to other contexts.

The coping strategies used to construct the rCSI in this report are listed here:

```{r table6, echo = FALSE}

Strategies <- c("Relied on less preferred, less expensive food", 
                 "Borrowed food or relied on help from friends or relatives", 
                 "Reduced the number of meals eaten per day",
                 "Restrict consumption by adults in order for young children to eat",
                 "Reduced portion size of meals")

Weights <- csi_weights

data.frame(Strategies, Weights) %>% kable()


```

##### Insert qualitative analysis about the coping strategies used by the community prior to the distribution here.

Calculation of the rCSI score for each household was done by multiplying the # of days the household utilized each coping strategy by the weighting value of the coping strategy, then summing the values for all strategies.

The maximum value of the rCSI per household is `r 7 * sum(csi_weights)`.

#### Figure 11: Coping Strategies Index scores disaggregated by location
```{r, echo=F, message=F, warning=F}

ggplot(scores, aes(x = !!sym(vars$geo), y = household_csi)) +
  geom_jitter(aes(fill = !!sym(vars$geo)), 
              width = 0.1, alpha = 0.4, shape = 21) +
  geom_boxplot(aes(fill = !!sym(vars$geo)), colour = "black", width = 0.5,
               show.legend = FALSE, outlier.shape = NA, alpha = 0.4) +
  xlab("") +
  ylab(paste0("rCSI Score (max = ", as.character(7 * sum(csi_weights)), ")")) +
  theme_bw() +
  theme(axis.text.x = element_text(face = "bold", angle = 45, hjust = 1)) +
  scale_fill_pander(guide = FALSE) +
  scale_color_pander(guide = FALSE)
  
```

##### Insert any narrative about the differences in scores among the disaggregated households here.


#### Figure 12: Coping Strategies Index household scores classified by food insecurity severity
```{r, echo = FALSE}

# max score on rCSI per household is 7 * (sum of all weights)
# to compare distributions across time ( or some other disagg) break the households into quantiles for each disagg
## First quantile is essentially "household did not use the equivalent of a non-serious CS (a 1) for a full week", max = 7
## Second quantile is "household used the equivalent of a non-serious CS (a 1 or 2) for at least a full week", max = 14
## Third quantile is "household used the equivalent of a serious CS (a 3) for at least a full week", max = 21
## Fourth quantile is "household used the equivalent of more than one serious CS (a 3 or 4) for at least a full week", max = 7 * weights vector

ApplyQuantiles <- function(x) {
  cut(x, breaks= c(0, 7, 14, 21, 7 * sum(csi_weights)), 
      labels=c("Least food insecure\n(1st quartile)", "Less food insecure\n(2nd quartile)", "More food insecure\n(3rd quartile)", "Most food insecure\n(4th quartile)"), include.lowest=TRUE)
}

scores_quant <- scores %>%
  mutate(quantile = sapply(household_csi, ApplyQuantiles))

n_dist <- scores_quant %>%  group_by(!!sym(vars$geo)) %>% summarize(n_dist = n())

scores_quant <- scores_quant %>%  group_by(quantile, !!sym(vars$geo)) %>% 
  summarise(n_quant = n()) %>% 
  merge(., n_dist, by = vars$geo) %>%  
  mutate(percentage = n_quant/n_dist*100)

scores_quant$quantile <- factor(scores_quant$quantile, levels = rev(c("Least food insecure\n(1st quartile)", "Less food insecure\n(2nd quartile)", "More food insecure\n(3rd quartile)", "Most food insecure\n(4th quartile)")))
#scores_quant$distribution <- factor(scores$distribution, levels = c("Distribution 3", "Distribution 2", "Distribution 1"))

ggplot(scores_quant, aes(y = percentage/100, x = !!sym(vars$geo), fill = quantile)) + 
  geom_bar(stat = "identity", color = "gray80") +
  #scale_x_discrete(labels = as_labeller(f_labs)) +
  scale_y_continuous(labels = scales::percent) +
  guides(fill = guide_legend(reverse = TRUE,
                             title.position = "top",
                             label.position = "bottom",
                             keywidth = 3,
                             nrow = 1)) +
  labs(x = NULL, y = NULL,
       fill = "Percentage of households falling in each category",
       subtitle = "Food insecurity severity by district") +
  theme(legend.position = "bottom",
        axis.text.y = element_text(face = "bold", hjust = 1, size = 12),
        axis.ticks.length = unit(0, "cm"),
        panel.grid.major.y = element_blank()) +
  scale_fill_brewer(palette = "RdYlGn") +
  coord_flip()
  
```

##### Insert narrative here

### Respondent preferences for future distributions

If the program were to be redone, `r round(sum(ona_df[[vars$preferred_modality]] == "vouchers")/nrow(ona_df), digits = 3)*100`% of the respondents would prefer to receive assistance in the form of vouchers, while `r round(sum(ona_df[[vars$preferred_modality]] == "the_equivalent")/nrow(ona_df), digits = 3)*100`% would prefer to receive the equivalent value in goods and services. `r round(sum(ona_df[[vars$preferred_modality]] == "cash")/nrow(ona_df), digits = 3)*100`% of respondents preferred to receive the cash.

Of the `r nrow(ona_df)` respondents, `r sum(!is.na(ona_df[[vars$reason_modality_preferred]]))` gave a reason why they preferred the modality.

\newline

#### Table 4: Reasons respondents preferred different assistance modalities (# of persons)
```{r, echo = FALSE}

select(ona_df, one_of(vars$reason_modality_preferred, vars$preferred_modality)) %>% 
  drop_na(!!sym(vars$reason_modality_preferred)) %>% 
  group_by(!!sym(vars$reason_modality_preferred), !!sym(vars$preferred_modality)) %>% 
  summarise(n = n()) %>% 
  spread(!!sym(vars$preferred_modality), n) %>% 
  .[order(.[[2]], decreasing = T),] %>% 
  pandoc.table()

```

##### Insert analysis of the "other" responses here.

## Protection & CARM

In response to questions about their safety while participating in the program:

* `r round(sum(ona_df[[vars$feel_less_safe]] != "No")/nrow(ona_df), digits = 3)*100`% of respondents said they felt less safe or more at risk by receiving the assistance.
* `r round(sum(ona_df[[vars$community_tension]] == "yes")/nrow(ona_df), digits = 3)*100`% of respondents said their participation in the program caused tensions between them and the community.
* `r round(sum(ona_df[[vars$household_tension]] == "yes")/nrow(ona_df), digits = 3)*100`% of respondents said their participation in the program caused tensions between them and the household.
* `r round(sum(ona_df[[vars$program_exchange]] == "yes")/nrow(ona_df), digits = 3)*100`% of respondents said that in order to be included in the program, they had to pay a fee, make a favor in a return, get involved in suspicious work, or work for someone in some other way.

##### Insert any qualitative analysis about the respondents' assessment of their safety here.

#### Figure 13: Profile of respondent understanding of and participation in CARM procedures
```{r, echo = FALSE}

filtered <- select(ona_df, one_of(vars$geo, vars$carm_aware_contact, vars$carm_would_report, vars$carm_ever_report)) %>% 
  mutate_at(vars(one_of(vars$carm_aware_contact, vars$carm_would_report, vars$carm_ever_report)), funs(lookup_yn$value[match(., lookup_yn$factor)])) %>% 
  group_by(!!sym(vars$geo)) %>% 
  summarise(carm_ever_report = sum(!!sym(vars$carm_ever_report))/n()*100,
            carm_would_report = sum(!!sym(vars$carm_would_report))/n()*100,
            carm_aware_contact = sum(!!sym(vars$carm_aware_contact))/n()*100) %>% 
  as.data.frame(.) %>%  
  melt(., id.vars = vars$geo)

labels <- c("Have you ever used one of our feedback mechanisms?",  "If you had a complaint or suggestion, would you report it?", "Are you aware of how to contact us?")

ggplot(filtered, aes(x = variable, y = value, fill = !!sym(vars$geo))) +
  geom_col(position = "dodge") +
  labs(x = "", 
       y = "% of respondents",
       title = "Percentage of households answering 'Yes'") +
    scale_x_discrete(labels = str_wrap(labels, width = 20)) + 
  coord_flip() +
  format_chart(legend_name = "District:") +
  geom_text(aes(label = paste0(as.character(round(value, digits = 1)), "%")), position = position_dodge(width=0.9), size = 2.5)
  
```

\newline

Of all respondents, `r sum(ona_df[[vars$carm_ever_report]] == "yes")` said they had ever used one of Mercy Corps' feedback mechanisms. Of those, `r round(sum(ona_df[[vars$carm_received_response]] == "yes", na.rm = T)/sum(ona_df[[vars$carm_ever_report]] == "yes", na.rm = T), digits = 2)*100`% said they received a response, and `r round(sum(ona_df[[vars$carm_satisfied_response]] == "yes", na.rm = T)/sum(ona_df[[vars$carm_ever_report]] == "yes", na.rm = T), digits = 2)*100`% said they were satisfied with the response.

\newline

#### Figure 14: Preferred methods for CARM reporting
```{r, echo = FALSE}

ggplot(filter(ona_df, !is.na(!!sym(vars$carm_prefer_report))), aes(x = !!sym(vars$carm_prefer_report), fill = !!sym(vars$carm_prefer_report))) +
  geom_bar() +
  labs(x = "", 
       y = "# of respondents",
       title = "How would you prefer to report a complaint or feedback?") +
  facet_grid(eval(expr(. ~ !!sym(vars$geo)))) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 20)) + 
  format_chart(textang = 45) +
  theme(legend.position = "none")

```

\newline

***

\newline

## General Conclusions and Recommendations

##### Insert general conclusions from the entire report, and recommendations for improving distributions here.

***